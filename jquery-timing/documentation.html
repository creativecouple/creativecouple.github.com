<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link type="image/gif" rel="shortcut icon" href="/favicon.gif"/>
<meta name="keywords" content="jQuery-timing,wait,repeat,delay,timed invocation chain,effects queue,tic,fxq" />
<meta name="author" content="CreativeCouple"/>
<title>timing: a jQuery plugin - Documentation of TIC</title>
<link type="text/css" rel="stylesheet" href="style.css"/>
<script type="text/javascript" src="http://code.jquery.com/jquery.min.js"></script>
<script type="text/javascript" src="jquery-timing.min.js?v=a3e22f7b84e7f4c5cc81ce51de1af79dded78727"></script>
<script type="text/javascript" src="documentation.js"></script>

<link type="text/css" rel="stylesheet" href="http://jquery.bassistance.de/treeview/jquery.treeview.css"/>
<script type="text/javascript" src="http://jquery.bassistance.de/treeview/jquery.treeview.js"></script>
</head>
<body>
<div style="float:right">
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/de_DE/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<div class="fb-like" data-href="http://creativecouple.github.com/jquery-timing/" data-send="true" data-layout="button_count" data-width="250" data-show-faces="false" data-font="verdana"></div>
<br/>
<div class="g-plusone" data-annotation="inline" data-width="250" data-href="http://creativecouple.github.com/jquery-timing/"></div>
</div>

<h1><a href="./">timing</a> <small>&mdash; a jQuery plugin<br/>
<small><a name="reference"></a>Documentation</small>
</small></h1>

<div class="left">
<p>On this page you find heavy technical stuff explaining how the Timed Invocation Chain (<abbr>tic</abbr>) is working and how it compares to the jQuery effects queue (<abbr>fxq</abbr>).</p>
<p>
Follow the navigation for documentation, examples, references, and further information.<br/>
&ndash; Have fun!
</p>
</div>

<div class="navigation">
<div class="left">
<h2>Navigation</h2>
<ul class="treeview">
	<li class="closed"><span>Precondition</span>
		<ul>
			<li><span><a href="./#precondition">Simplicity</a></span></li>
			<li><span><a href="./#dependency">Dependencies</a></span></li>
			<li><span><a href="./#inclusion">Include in your page</a></span></li>
			<li><span><a href="./#download">Download &amp; License</a></span></li>
			<li><span><a href="./#todo">Ongoing work</a></span></li>
		</ul>
	</li>
	<li class=""><span>Documentation</span>
		<ul>
			<li><span><a href="documentation.html#tic">Introducing <abbr>tic</abbr>: the Timed Invocation Chain</a></span></li>
			<li><span><a href="documentation.html#comparison">Effects Queue (<abbr>fxq</abbr>) vs. Timed Invocation Chain (<abbr>tic</abbr>)</a></span></li>
			<li><span><a href="documentation.html#combination"><abbr>fxq</abbr> and <abbr>tic</abbr> combined: why friends have to <code>.join()</code></a></span></li>
		</ul>
	</li>
	<li class="closed"><span>Basic Examples</span>
		<ul>
			<li><span><a href="basics.html#basics">Example 1: Blinking by repeated toggling of CSS class</a></span></li>
			<li><span><a href="basics.html#example2">Example 2: Blinking a given number of times</a></span></li>
			<li><span><a href="basics.html#example3">Example 3: Wait a timeout before blinking</a></span></li>
			<li><span><a href="basics.html#example4">Example 4: Clock display with one short blink per second</a></span></li>
			<li><span><a href="basics.html#example5">Example 5: Clock display with double blink per second</a></span></li>
		</ul>
	</li>
	<li class="closed"><span>Advanced techniques with <abbr>tic</abbr></span>
		<ul>
			<li><span><a href="advanced.html#advanced">Example 6: Generating password with fake progress</a></span></li>
			<li><span><a href="advanced.html#example7">Example 7: Removing DOM elements one by one</a></span></li>
			<li><span><a href="advanced.html#example8">Example 8: Invoke callback function on timing</a></span></li>
			<li><span><a href="advanced.html#example9">Example 9: Static usage of wait() &amp; co</a></span></li>
			<li><span><a href="advanced.html#example10">Example 10: the jQueryfied <code>for</code>-loop</a></span></li>
		</ul>
	</li>
	<li class="closed"><span>Ultimate timing control with <abbr>tic</abbr> and <abbr>fxq</abbr></span>
		<ul>
			<li><span><a href="ultimate.html#ultimate">Example 11: repeated fading</a></span></li>
			<li><span><a href="ultimate.html#example12">Example 12: playing pong</a></span></li>
			<li><span><a href="ultimate.html#example13">Example 13: scheduling different elements' animations</a></span></li>
			<li><span><a href="ultimate.html#outlook">Outlook: Something missing here?</a></span></li>
		</ul>
	</li>
	<li class="closed"><span>Method reference</span>
		<ul>
			<li><span><a href="reference.html#reference"><code>.join()</code></a></span></li>
			<li><span><a href="reference.html#.repeat"><code>.repeat()</code></a></span></li>
			<li><span><a href="reference.html#$.repeat"><code>$.repeat()</code></a></span></li>
			<li><span><a href="reference.html#.then"><code>.then()</code></a></span></li>
			<li><span><a href="reference.html#$.then"><code>$.then()</code></a></span></li>
			<li><span><a href="reference.html#.unrepeat"><code>.unrepeat()</code></a></span></li>
			<li><span><a href="reference.html#$.unrepeat"><code>$.unrepeat()</code></a></span></li>
			<li><span><a href="reference.html#.until"><code>.until()</code></a></span></li>
			<li><span><a href="reference.html#.unwait"><code>.unwait()</code></a></span></li>
			<li><span><a href="reference.html#$.unwait"><code>$.unwait()</code></a></span></li>
			<li><span><a href="reference.html#.wait"><code>.wait()</code></a></span></li>
			<li><span><a href="reference.html#$.wait"><code>$.wait()</code></a></span></li>
		</ul>
	</li>
</ul>
<script>
$('.treeview').treeview();
</script>
</div>
<div class="left">
<h2><a name="contact"></a>Contact</h2>
<address>
	<span><span style="color:#800">C   t</span>   <span style="color:#006">C   l</span>   m   e</span>
	<span>  <span style="color:#800">e   v</span>   <span style="color:#006">u</span>   &#64;   .</span>
	<span>   <span style="color:#800">a   e</span>   <span style="color:#006">p</span>   g   n</span>
	<span> <span style="color:#800">r   i</span>   <span style="color:#006">o   e</span>   x   t</span>
</address>
<p><small>Copyright &copy; 2012 &ndash; <a href="http://www.creativecouple.de/">CreativeCouple</a>, Peter Liske</small></p>
</div>
</div>

<div class="content">

<a name="tic"></a>
<div class="block">
<h2>Introducing <abbr>tic</abbr>: the Timed Invocation Chain</h2>

<p>After long time working with jQuery in different projects I found that there was one thing I always (re)invented again
&ndash; convenient methods for timing.
Of course, using <code>window.setTimeout()</code> and <code>window.setInterval()</code> is not a big deal.
But it becomes one if you leave the easy examples and implement really sophisticated use cases.
So at the end I decided to write this plugin you are studying right now &ndash; <em>jquery-timing</em>.</p>
<p>With this plugin I use a technique which I use to call the Timed Invocation Chain.
For less redundancy and faster reading I will abbreviate it with <abbr>tic</abbr> from now on.</p>
<h3>But what does <abbr>tic</abbr> mean?</h3>
<p>
<abbr>tic</abbr> is an easy way to postpone method execution when written in a jQuery style &ndash; a long method call concatenation, always using the return value of the previous function call as object to work on with the next function.
jQuery highly bases on exactly that method concatenation schema:
</p>
<pre title="example for a jQuery invocation chain"><b>$</b>(&hellip;)&#8203;.<b>show</b>()&#8203;.<b>css</b>(&hellip;)&#8203;.<b>click</b>(&hellip;)&#8203;.<b>find</b>(&hellip;)&#8203;.<b>hover</b>(&hellip;).<b>keypress</b>(&hellip;)&#8203;.<b>each</b>(&hellip;)&#8203;.<b>first</b>(&hellip;).<b>css</b>(&hellip;)... // etc</pre>
<p>
And that's the point!<br/>
Using a method on jQuery selection objects almost always returns the same or another jQuery object to work with.
So it is an invocation chain where all objects in between again are jQuery selection objects.
</p>
<h3>And what does that knowledge help me?</h3>
<p>
If you know that any object result within a long invocation chain is of the same type (or for other programming languages the same class or interface),
then you also know that they share a common set of methods that can be invoked.
In our case we just have to look at the very first object <code><b>$</b>(&hellip;)</code> and list all the methods that can be invoked on that object.
We then can <em>forecast</em> that each and every invocation step in the long invocation chain will allow us to call <em>exactly these methods</em>.
</p>
<h3>How it works</h3>
<p>
So this is the simple way how it works: The first call to <code>.wait()</code>, <code>.repeat()</code>, or <code>.join()</code> will internally create a placeholder object being aware of all the methods that <em>could</em> be called.
When they are then called in the invocation chain, meaning when JavaScript does execute the code, then the smart placeholder object collects all invocations in a call stack.
It stores the function names and the arguments that were given on each call.
The outcome is a call stack that allows us to iterate in any possible manner.
With this call stack in our hands we can include waiting, repeating, and a lot other stuff which would break the scope of this plugin.
</p>
<p>
Thus we achieve a Timed Invocation Chain &ndash; <abbr>tic</abbr>.
</p>

</div>

<a name="comparison"></a>
<div class="block">
<h2>Effects Queue (<abbr>fxq</abbr>) vs. Timed Invocation Chain (<abbr>tic</abbr>)</h2>

<p>
Some might ask if it's necessary to hack such a weird stuff when we already have a working effects queue in jQuery.
Actually the jQuery effects queue, which I will abbreviate as <abbr>fxq</abbr> from now on, does support a wide range of animations, delays, custom queuing and unqueuing, etc.
But there are several differences between <abbr>fxq</abbr> and <abbr>tic</abbr>, which I try to explain with the following table:
</p>
<table>
<tr><td></td><th><abbr>fxq</abbr> &ndash; jQuery effects queue</th><th><abbr>tic</abbr> &ndash; timed invocation chain</th></tr>
<tr><th>underlying technique</th><td>enqueue explicite animations and effects</td><td>postpone method invocations themselves</td></tr>
<tr><th>return value of methods</th><td>same jQuery object</td><td>placeholder object collecting all concatenated function calls</td></tr>
<tr><th>method support</th><td>only functions being designed to enqueue something</td><td>any jQuery function that returns a jQuery object</td></tr>
<tr><th>stopping execution</th><td>stop ongoing animation immediately at the current state</td><td>interrupt ongoing timeouts or intervals only</td></tr>
<tr><th>scope</th><td>each <abbr>fxq</abbr> can be accessed from anywhere</td><td>each <abbr>tic</abbr> is restricted by its invocation chain</td></tr>
<tr><th>method delay</th><td><code>.delay(<em>timeout</em>).queue(<em>callback</em>)</code></td><td><code>.wait(<em>timeout</em>,<em>callback</em>)</code></td></tr>
<tr><th>loop iterations</th><td>not possible</td><td><code>.repeat()</code> and <code>.until()</code> with custom end conditions</td></tr>
</table>
<p>
As you can see both techniques have their pros and cons.
And we see that <abbr>tic</abbr> is not <em>better</em> than <abbr>fxq</abbr>.
It neither claims to be an improvement.</p>
<p>
I just say that <abbr>fxq</abbr> is one way to time your stuff and <abbr>tic</abbr> is another way to do so.</p>
</div>

<a name="combination"></a>
<div class="block">
<h2><abbr>fxq</abbr> and <abbr>tic</abbr> combined: why friends have to <code>.join()</code></h2>

<p>Good news: You can have all advantages from both worlds!</p>
<p>
The <abbr>tic</abbr>-method <code>.join(<em>[queueName]</em>)</code> allows a timed invocation chain to wait until all the animations and effects currently being queued in a <abbr>fxq</abbr> finished.
That also means that in case of <code>.stop()</code>ing the <abbr>fxq</abbr> our <abbr>tic</abbr> will not continue. This can be good or bad &ndash; depending on your use case and your code. 
</p>
<p>So maybe now it's time to check out the examples for easy time control with jQuery: <a href="basics.html">basic examples</a>, <a href="advanced.html">advanced examples</a>, or <a href="ultimate.html"><abbr>fxq</abbr> and <abbr>tic</abbr> combined</a>.</p>
<p>And don't forget: <em>write less. do more.</em></p>

</div>

</div>

</body>
</html>
